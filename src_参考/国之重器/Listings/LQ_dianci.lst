C251 COMPILER V5.60.0,  LQ_dianci                                                          25/09/23  21:38:01  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE LQ_dianci
OBJECT MODULE PLACED IN .\Objects\LQ_dianci.obj
COMPILER INVOKED BY: C:\Keil5\load\C251\BIN\C251.EXE user\Dianci\LQ_dianci.c LARGE INTR2 BROWSE INCDIR(.\user;.\user\Dia
                    -nci) DEBUG PRINT(.\Listings\LQ_dianci.lst) TABS(2) OBJECT(.\Objects\LQ_dianci.obj) 

stmt  level    source

    1          /*LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
    2          【平    台】北京龙邱智能科技STC16核心板
    3          【编    写】chiusir
    4          【E-mail  】chiusir@163.com
    5          【软件版本】V1.1 版权所有，单位使用请先联系授权
    6          【最后更新】2021年1月23日
    7          【相关信息参考下列地址】
    8          【网    站】http://www.lqist.cn
    9          【淘宝店铺】http://longqiu.taobao.com
   10          ------------------------------------------------
   11          【IDE】STC16
   12          【Target 】 C251Keil5.6及以上
   13          【SYS PLL】 30MHz使用内部晶振
   14          =================================================================
   15          STC16相关配套视频：
   16          龙邱科技B站网址：https://space.bilibili.com/95313236
   17          STC16环境下载参考视频： https://www.bilibili.com/video/BV1gy4y1p7T1/
   18          STC16一体板子介绍视频： https://www.bilibili.com/video/BV1Jy4y1e7R4/
   19          =================================================================
   20          下载时, 选择时钟 30MHZ (用户可自行修改频率).
   21          STC16F初次下载:先用IRCBND=0，ISP界面设置为24M，
   22          然后IRCBND=0，下载频率为30M；
   23          或者IRCBND=1，下载频率为30M；好用为准
   24          QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ*/
   25          #include "LQ_dianci.h"
   26          #include "include.h"
   27          #include "LQ_PID.h"
   28          
   29          extern pid_param_t Speed_PID;
   30          extern pid_param_t Direc_PID;
   31          
   32          long bmq_juli=0;      //编码器积分
   33          long tly_jifen=0;     //陀螺仪积分
   34          
   35          short leftP=0,leftV=0,rightV=0,rightP=0,zhongjian=0;//电感
   36          long TempAngle = 0;           // 差值
   37          short MotorDuty1=0;           // 定义左电机全局变量
   38          short MotorDuty2=0;           // 定义右电机全局变量
   39          short ECPULSE1 = 0;           // 定义左编码器全局变量 
   40          short ECPULSE2 = 0;           // 定义右编码器全局变量
   41          
   42          volatile short Target_Speed = 0;          // 速度全局变量
   43          
   44          int time = 0;  //时间标志            
   45          int chazhi_sancha=0; //岔路差值
   46          int chazhi_huandao=0; //环岛差值
   47          
   48          int hdcha=0,huandao=0,huandao1=0; //环岛标志位    
   49          
   50          int yxy=0;
   51          int Forkchu=0;//出岔路标志
   52          int count = 0;//次数标志                     
   53          int Fork=0,Fork_L=0,Fork_R=0,Forking=0;               // 三岔路标志
   54          int Round=0,Rounding=0,Round_Out=0,Detection=0;       //环岛标志
   55          
   56          int Out_dw=0;//方向外环
   57          int Out_dn=0;//方向内环
   58          int Out_s=0;//速度环
C251 COMPILER V5.60.0,  LQ_dianci                                                          25/09/23  21:38:01  PAGE 2   

   59          
   60          void timer0_int (void) interrupt 1
   61          {
   62   1          ICM_Get_Raw_data(&aacx1,&aacy1,&aacz1,&gyrox1,&gyroy1,&gyroz1);//获取陀螺仪的数据
   63   1          //tly_jifen+=gyroz1;
   64   1      
   65   1          ECPULSE1 = Read_Encoder(1);               // 左电机 母板上编码器1，小车前进为负值
   66   1          ECPULSE2 = Read_Encoder(2);               // 右电机 母板上编码器2，小车前进为正值
   67   1        
   68   1          InductorNormal();
   69   1      
   70   1        if(Go == 1)
   71   1        {
   72   2          Go=2;
   73   2          Round = 0;
   74   2          Fork = 0;       
   75   2          count = 0;
   76   2          Forkchu = 1;
   77   2        }
   78   1        if(Go==2)
   79   1        {
   80   2          time++;
   81   2        }
   82   1          
   83   1          Control();
   84   1        
   85   1        //TempAngle=(leftV-rightV)*100/(leftV+rightV);  
   86   1        if(Round==0&&Fork==0) TempAngle=(leftV-rightV);//正常循迹
   87   1        
   88   1        if(time==3)
   89   1        {
   90   2          Out_dw=dircontrol(TempAngle); //外环
*** WARNING C188 IN LINE 90 OF user\Dianci\LQ_dianci.c: 'parameter 1': value truncated
   91   2          time=0;
   92   2        }
   93   1          
   94   1          //Out_dw=((int)dircontrol(TempAngle));  
   95   1            Out_dn=diranglecontrol(Out_dw); //内环
   96   1      
   97   1        if((Round ==4)||(Round ==5)&&huandao==0)
   98   1        {
   99   2          Out_dn=diranglecontrol(TempAngle);//环岛内环
*** WARNING C188 IN LINE 99 OF user\Dianci\LQ_dianci.c: 'parameter 1': value truncated
  100   2        } 
  101   1        
  102   1        if(Forkchu==1&&yxy==1)
  103   1        {
  104   2          Target_Speed=22;
  105   2        }
  106   1        
  107   1      //  if(Out_d>1000)Out_d=1000; 
  108   1      //  if(Out_d<-1000)Out_d=-1000;
  109   1          Out_s=speedcontrol((int)((ECPULSE1-ECPULSE2)/2),Target_Speed);//速度环
  110   1      //  if(Out_s>150)Out_s=150;
  111   1      //  if(Out_s<-150)Out_s=-150;
  112   1      
  113   1        
  114   1          MotorDuty1 =Out_s - Out_dn;//电机1输出
  115   1          MotorDuty2 =Out_s + Out_dn;//电机2输出
  116   1      
  117   1             //电机限幅
  118   1          /*if(MotorDuty1 > 8000)MotorDuty1 = 8000;else if(MotorDuty1 < -8000)MotorDuty1 = -8000;
  119   1          if(Speed_PID.out > 8000)Speed_PID.out = 8000;else if(Speed_PID.out < -8000)Speed_PID.out = -8000;
  120   1      
  121   1          if(MotorDuty2 > 8000)MotorDuty2 = 8000;else if(MotorDuty2 < -8000)MotorDuty2 = -8000;
  122   1          if(Direc_PID.out > 8000)Direc_PID.out = 8000;else if(Direc_PID.out < -8000)Direc_PID.out = -8000;*/
C251 COMPILER V5.60.0,  LQ_dianci                                                          25/09/23  21:38:01  PAGE 3   

  123   1          
  124   1          if(Go == 0||Go == 3)
  125   1        {
  126   2          MotorDuty1=0;
  127   2          MotorDuty2=0;
  128   2        }
  129   1        
  130   1          MotorCtrl(MotorDuty1,MotorDuty2);
  131   1      }
  132          
  133           
  134          /*LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
  135          【函数名】void InductorNormal (void)
  136          【功  能】电磁车演示程序
  137          【作  者】chiusir
  138          【最后更新】2021年1月22日 
  139          【软件版本】V1.0
  140          /QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ*/
  141          unsigned int data diangan[5];
  142          void InductorNormal (void)
  143          {
  144   1          diangan[0]=ADC_Read_Average(8,5);     // 读取ADC8通道值   P00
  145   1          diangan[1]=ADC_Read_Average(9,5);     // 读取ADC9通道值   P01
  146   1          diangan[2]=ADC_Read_Average(10,5);    // 读取ADC10通道值  P02
  147   1          diangan[3]=ADC_Read_Average(11,5);    // 读取ADC11通道值  P03
  148   1          diangan[4]=ADC_Read_Average(0,5);     // 读取ADC0通道值   P10
  149   1          
  150   1          leftV =  (float)((diangan[0] - 0.0) / (1700.0 - 0.0)) * 100.0;    // 电感归一化
  151   1          leftP =  (float)(diangan[1] - 100.0) / (4095.0 - 100.0) * 100.0;    // 电感归一化
  152   1          rightP = (float)(diangan[2] - 100.0) / (4095.0 - 100.0) * 100.0;    // 电感归一化
  153   1          rightV = (float)((diangan[3] - 0.0) / (1900.0 - 0.0)) * 100.0;    // 电感归一化 
  154   1          zhongjian = (float)(diangan[4] - 100.0) / (4095.0 - 100.0) * 100.0;
  155   1          
  156   1          leftP = (leftP < 0) ? 0 : leftP;            //归一化后限制输出幅度
  157   1          leftP = (leftP > 100) ? 100 : leftP;        //归一化后限制输出幅度
  158   1          rightV = (rightV < 0) ? 0 : rightV;         //归一化后限制输出幅度
  159   1          rightV = (rightV > 100) ? 100 : rightV;     //归一化后限制输出幅度
  160   1          leftV = (leftV < 0) ? 0 : leftV;            //归一化后限制输出幅度
  161   1          leftV = (leftV > 100) ? 100 : leftV;        //归一化后限制输出幅度
  162   1          rightP = (rightP < 0) ? 0 : rightP;         //归一化后限制输出幅度
  163   1          rightP = (rightP > 100) ? 100 : rightP;     //归一化后限制输出幅度
  164   1          zhongjian = (zhongjian < 0) ? 0 : zhongjian;
  165   1          zhongjian = (zhongjian > 100) ? 100 : zhongjian;  
  166   1      }
  167          
  168          void Control(void)
  169          {
  170   1        int i;
  171   1        if(Forkchu==1)
  172   1        {
  173   2          TempAngle=(leftV-rightV);
  174   2          if(diangan[4]>1600)
  175   2          {
  176   3            Forkchu=0;
  177   3          }
  178   2        } 
  179   1      //方案一
  180   1      //方案一
  181   1      //方案一
  182   1        if(P32==0&&P33==0)
  183   1      {
  184   2         if(Round==1)
  185   2          {
  186   3            Discern4();   //环岛处理    
  187   3          }
  188   2        else  if(Fork==1)
C251 COMPILER V5.60.0,  LQ_dianci                                                          25/09/23  21:38:01  PAGE 4   

  189   2          {
  190   3            sancha();     //三岔处理
  191   3          }
  192   2      else  
  193   2        {
  194   3                // 识别环岛
  195   3             if(((Detection==0)&&(leftV>68)&&(rightV>78)&&(diangan[4]>2100)&&(diangan[1]+diangan[2])>3200)&&Rou
             -nd==0&&Fork==0) 
  196   3             {
  197   4                 Detection=1;         
  198   4                 LED_Ctrl(LED2,ON);
  199   4             }
  200   3             else if((bmq_juli>5500)&&Detection==1)      
  201   3             {
  202   4                 Round = 1;
  203   4             }
  204   3                //识别岔路
  205   3             //if(diangan[4]<1050&&(diangan[1]+diangan[2])<1650&&(diangan[1]+diangan[2])>1250&&leftV>50&&rightV>5
             -0&&Round==0&&Fork==0&&Forkchu==0)
  206   3             if(diangan[4]<1000&&(diangan[1]+diangan[2])<500&&(diangan[1]+diangan[2])>200&&Round==0&&Fork==0&&Fork
             -chu==0)
  207   3                  {
  208   4                      Fork = 1;
  209   4                      LED_Ctrl(LED2,ON);        
  210   4                  }
  211   3                //正常循迹目标速度
  212   3             if(Forkchu==1)
  213   3             {
  214   4               Target_Speed =15;
  215   4             }
  216   3            if(Forkchu==0)  
  217   3            {        
  218   4             if(Round == 1&&Fork == 0)
  219   4             {
  220   5               Target_Speed =25;
  221   5             }
  222   4             if(Round == 0&&Fork == 0)
  223   4             {
  224   5               Target_Speed =25;
  225   5             }
  226   4            }
  227   3        }
  228   2          if(Detection==1)
  229   2            {
  230   3              bmq_juli+=(ECPULSE1-ECPULSE2);
  231   3            }
  232   2          if(Fork==1&&Forking==0)
  233   2            {
  234   3              tly_jifen+=gyroz1;
  235   3            }
  236   2          if(Round==1)
  237   2            {
  238   3              tly_jifen+=gyroz1;
  239   3            }
  240   2      } 
  241   1      //{
  242   1      //  if((Round ==4)||(Round ==5))
  243   1      //    {
  244   1      //      Discern();    //环岛处理    
  245   1      //    }
  246   1      //  else  if(Fork==1)
  247   1      //    {
  248   1      //      sancha();     //三岔处理
  249   1      //    }
  250   1      //else  
  251   1      //  {
C251 COMPILER V5.60.0,  LQ_dianci                                                          25/09/23  21:38:01  PAGE 5   

  252   1      //          // 识别环岛   
  253   1      //    if(((Detection==0)&&(leftV>70)&&(rightV>70)&&(diangan[4]+diangan[3]>3350)&&(diangan[1]+diangan[2])>31
             -00)&&Round==0&&Fork==0)  
  254   1      //      {
  255   1      //        Detection=1;
  256   1      //        hdcha=(diangan[1]-diangan[2]);
  257   1      //      }     
  258   1      //    if(hdcha>-50&&Detection==1&&(leftV>rightV))
  259   1      //     {
  260   1      //      Detection=2;
  261   1      //     }
  262   1      //    if(hdcha<-100&&Detection==1&&(leftV<rightV))
  263   1      //     {
  264   1      //      Detection=3;
  265   1      //     }
  266   1      //    if(Detection==2&&bmq_juli>2000)
  267   1      //      {
  268   1      //        Round=5;
  269   1      //        LED_Ctrl(LED2,ON);
  270   1      //        Detection=4;
  271   1      //        bmq_juli=0;
  272   1      //      }
  273   1      //    if(Detection==3&&bmq_juli>2000)
  274   1      //      {
  275   1      //        Round=4;
  276   1      //        LED_Ctrl(LED2,ON);
  277   1      //        Detection=4;
  278   1      //        bmq_juli=0;
  279   1      //      }
  280   1      //          //识别岔路
  281   1      //     //if(diangan[4]<1050&&(diangan[1]+diangan[2])<1650&&(diangan[1]+diangan[2])>1250&&leftV>50&&rightV>5
             -0&&Round==0&&Fork==0&&Forkchu==0)
  282   1      //      if(diangan[4]<1000&&(diangan[1]+diangan[2])<500&&(diangan[1]+diangan[2])>200&&Round==0&&Fork==0&&For
             -kchu==0)
  283   1      //      {
  284   1      //        Fork = 1;
  285   1      //        LED_Ctrl(LED2,ON);        
  286   1      //      }
  287   1      //          //正常循迹目标速度
  288   1      //     if(Round == 0&&Fork == 0)
  289   1      //         {
  290   1      //          if((leftV<5)&&(rightV<5))
  291   1      //          {
  292   1      //            Target_Speed =30;
  293   1      //          }
  294   1      //          else if((leftV>60)&&(rightV>60))
  295   1      //          {
  296   1      //            Target_Speed =30;
  297   1      //          }
  298   1      //          else if((leftV>5)&&(leftV<60)&&(rightV<60)&&(rightV>5))
  299   1      //          {
  300   1      //            Target_Speed =30;
  301   1      //          }
  302   1      //         }
  303   1      //  }
  304   1      //    if(Detection==2||Detection==3)
  305   1      //      {
  306   1      //        bmq_juli+=(ECPULSE1-ECPULSE2);
  307   1      //      }
  308   1      //    if(Fork==1&&Forking==0)
  309   1      //      {
  310   1      //        tly_jifen+=gyroz1;
  311   1      //      }
  312   1      //    if((Round ==4)||(Round ==5)&&(huandao==0))
  313   1      //    {
  314   1      //      bmq_juli+=(ECPULSE1-ECPULSE2);
C251 COMPILER V5.60.0,  LQ_dianci                                                          25/09/23  21:38:01  PAGE 6   

  315   1      //      tly_jifen+=gyroz1;
  316   1      //    }
  317   1      //}
  318   1      //方案二
  319   1      //方案二
  320   1      //方案二  
  321   1          if(P32==1&&P33==0)      
  322   1      {
  323   2        if(Round ==4)
  324   2          {
  325   3            Discern();    //环岛处理    
  326   3          }
  327   2        else  if(Fork==1)
  328   2          {
  329   3            sancha();     //三岔处理
  330   3          }
  331   2      else  
  332   2        {
  333   3                // 识别环岛   
  334   3          if(((Detection==0)&&(leftV>70)&&(rightV>70)&&(diangan[4]+diangan[3]>3350)&&(diangan[1]+diangan[2])>3100
             -)&&Round==0&&Fork==0)  
  335   3            {
  336   4              Detection=1;
  337   4            } 
  338   3          if(Detection==1)
  339   3          {
  340   4            hdcha=(diangan[1]-diangan[2]);
  341   4          }
  342   3          if(hdcha<-100&&Detection==1)
  343   3           {
  344   4            Detection=2;
  345   4           }
  346   3          if(Detection==2&&bmq_juli>4200)
  347   3            {
  348   4              Round=4;
  349   4              LED_Ctrl(LED2,ON);
  350   4              Detection=3;
  351   4              bmq_juli=0;
  352   4            }
  353   3                //识别岔路
  354   3           //if(diangan[4]<1050&&(diangan[1]+diangan[2])<1650&&(diangan[1]+diangan[2])>1250&&leftV>50&&rightV>50&
             -&Round==0&&Fork==0&&Forkchu==0)
  355   3            if(diangan[4]<1000&&(diangan[1]+diangan[2])<500&&(diangan[1]+diangan[2])>200&&Round==0&&Fork==0&&Forkc
             -hu==0)
  356   3            {
  357   4              Fork = 1;
  358   4              LED_Ctrl(LED2,ON);        
  359   4            }
  360   3                //正常循迹目标速度
  361   3           if(Round == 0&&Fork == 0)
  362   3               {
  363   4                if((leftV<5)&&(rightV<5))
  364   4                {
  365   5                  Target_Speed =30;
  366   5                }
  367   4                else if((leftV>60)&&(rightV>60))
  368   4                {
  369   5                  Target_Speed =30;
  370   5                }
  371   4                else if((leftV>5)&&(leftV<60)&&(rightV<60)&&(rightV>5))
  372   4                {
  373   5                  Target_Speed =30;
  374   5                }
  375   4               }
  376   3        }
  377   2          if(Detection==2)
C251 COMPILER V5.60.0,  LQ_dianci                                                          25/09/23  21:38:01  PAGE 7   

  378   2            {
  379   3              bmq_juli+=(ECPULSE1-ECPULSE2);
  380   3            }
  381   2          if(Fork==1&&Forking==0)
  382   2            {
  383   3              tly_jifen+=gyroz1;
  384   3            }
  385   2          if((Round ==4)&&(huandao==0))
  386   2          {
  387   3            bmq_juli+=(ECPULSE1-ECPULSE2);
  388   3            tly_jifen+=gyroz1;
  389   3          }
  390   2      }
  391   1      //方案三
  392   1      //方案三
  393   1      //方案三  
  394   1        if(P33==1&&P32==0)        
  395   1      {
  396   2        if(Round ==4)
  397   2          {
  398   3            Discern3();   //环岛处理    
  399   3          }
  400   2        else  if(Fork==1)
  401   2          {
  402   3            sancha();     //三岔处理
  403   3          }
  404   2      else  
  405   2        {
  406   3                // 识别环岛   
  407   3          if(((Detection==0)&&(leftV>70)&&(rightV>70)&&(diangan[4]+diangan[3]>3350)&&(diangan[1]+diangan[2])>3100
             -)&&Round==0&&Fork==0)  
  408   3            {
  409   4              Detection=1;
  410   4            } 
  411   3          if(Detection==1)
  412   3          {
  413   4            hdcha=(diangan[1]-diangan[2]);
  414   4          }
  415   3          if(hdcha<-100&&Detection==1)
  416   3           {
  417   4            Detection=2;
  418   4           }
  419   3          if(Detection==2&&bmq_juli>4600)
  420   3            {
  421   4              Round=4;
  422   4              LED_Ctrl(LED2,ON);
  423   4              Detection=3;
  424   4              bmq_juli=0;
  425   4            }
  426   3                //识别岔路
  427   3           //if(diangan[4]<1050&&(diangan[1]+diangan[2])<1650&&(diangan[1]+diangan[2])>1250&&leftV>50&&rightV>50&
             -&Round==0&&Fork==0&&Forkchu==0)
  428   3            if(diangan[4]<1000&&(diangan[1]+diangan[2])<500&&(diangan[1]+diangan[2])>200&&Round==0&&Fork==0&&Forkc
             -hu==0)
  429   3            {
  430   4              Fork = 1;
  431   4              LED_Ctrl(LED2,ON);        
  432   4            }
  433   3                //正常循迹目标速度
  434   3           if(Round == 0&&Fork == 0)
  435   3              {
  436   4               if(Forkchu==1)
  437   4               {
  438   5                  Target_Speed =20;
  439   5               }
  440   4               if(Forkchu==0)
C251 COMPILER V5.60.0,  LQ_dianci                                                          25/09/23  21:38:01  PAGE 8   

  441   4               {
  442   5                if((leftV<5)&&(rightV<5))
  443   5                {
  444   6                  Target_Speed =25;
  445   6                }
  446   5                else if((leftV>60)&&(rightV>60))
  447   5                {
  448   6                  Target_Speed =25;
  449   6                }
  450   5                else if((leftV>5)&&(leftV<60)&&(rightV<60)&&(rightV>5))
  451   5                {
  452   6                  Target_Speed =25;
  453   6                }
  454   5               }
  455   4              }
  456   3        }
  457   2          if(Detection==2)
  458   2            {
  459   3              bmq_juli+=(ECPULSE1-ECPULSE2);
  460   3            }
  461   2          if(Fork==1&&Forking==0)
  462   2            {
  463   3              tly_jifen+=gyroz1;
  464   3            }
  465   2          if((Round ==4)&&(huandao==0))
  466   2          {
  467   3            bmq_juli+=(ECPULSE1-ECPULSE2);
  468   3            tly_jifen+=gyroz1;
  469   3          }
  470   2      }
  471   1      //方案四
  472   1      //方案四
  473   1      //方案四  
  474   1        if(P33==1&&P32==1) 
  475   1      {
  476   2         yxy=1;
  477   2         if(Round==1)
  478   2          {
  479   3            Discern4();   //环岛处理    
  480   3          }
  481   2        else  if(Fork==1)
  482   2          {
  483   3            sancha();     //三岔处理
  484   3          }
  485   2      else  
  486   2        {
  487   3                // 识别环岛
  488   3             if(((Detection==0)&&(leftV>68)&&(rightV>78)&&(diangan[4]>2100)&&(diangan[1]+diangan[2])>3200)&&Rou
             -nd==0&&Fork==0) 
  489   3             {
  490   4                 Detection=1;         
  491   4                 LED_Ctrl(LED2,ON);
  492   4             }
  493   3             else if((bmq_juli>4700)&&Detection==1)      //2600     //4000
  494   3             {
  495   4                 Round = 1;
  496   4             }
  497   3                //识别岔路
  498   3             //if(diangan[4]<1050&&(diangan[1]+diangan[2])<1650&&(diangan[1]+diangan[2])>1250&&leftV>50&&rightV>5
             -0&&Round==0&&Fork==0&&Forkchu==0)
  499   3             if(diangan[4]<1000&&(diangan[1]+diangan[2])<500&&(diangan[1]+diangan[2])>200&&Round==0&&Fork==0&&Fork
             -chu==0)
  500   3                  {
  501   4                      Fork = 1;
  502   4                      LED_Ctrl(LED2,ON);        
  503   4                  }
C251 COMPILER V5.60.0,  LQ_dianci                                                          25/09/23  21:38:01  PAGE 9   

  504   3                //正常循迹目标速度
  505   3             if(Round == 1&&Fork == 0)
  506   3             {
  507   4               Target_Speed =20;
  508   4             }
  509   3             if(Round == 0&&Fork == 0)
  510   3             {
  511   4               Target_Speed =31;
  512   4             }
  513   3        }
  514   2          if(Detection==1)
  515   2            {
  516   3              bmq_juli+=(ECPULSE1-ECPULSE2);
  517   3            }
  518   2          if(Fork==1&&Forking==0)
  519   2            {
  520   3              tly_jifen+=gyroz1;
  521   3            }
  522   2          if(Round==1)
  523   2            {
  524   3              tly_jifen+=gyroz1;
  525   3            }
  526   2      } 
  527   1      }
*** WARNING C47 IN LINE 170 OF user\Dianci\LQ_dianci.c: 'i': unreferenced local variable
  528          
  529          void sancha(void)   
  530          {
  531   1        if(Fork==1&&count==0&&(tly_jifen>>10)>-150) //右岔路      //纯陀螺仪积分-300，差值-40//  
  532   1         {
  533   2           chazhi_sancha-=30;
  534   2           TempAngle=chazhi_sancha;
  535   2           if(TempAngle<-70)TempAngle=-70;
  536   2           Fork_R = 1;
  537   2         }
  538   1        else if(Fork_R = 1&&(tly_jifen>>10)<-150)
  539   1         {
  540   2           Forking=1;
  541   2           TempAngle=(leftV-rightV);
  542   2           if(Fork_R==1&&Forking==1)
  543   2           {
  544   3             TempAngle=(leftV-rightV);
  545   3             bmq_juli+=(ECPULSE1-ECPULSE2);      
  546   3           }
  547   2           if(bmq_juli>=10000)
  548   2           {
  549   3             if(Go==2)Go=3;
  550   3             LED_Ctrl(LED2,OFF);
  551   3             bmq_juli=0;
  552   3           }
  553   2         }
  554   1       /*if(Fork==1&&count==0&&time1<110) //右岔路
  555   1         {
  556   1           TempAngle=-20;
  557   1           time1++;
  558   1           Fork_R = 1;
  559   1           Target_Speed =0;
  560   1         }
  561   1         else if(Fork_R==1&&time1>=110)
  562   1         {
  563   1           Target_Speed =15; 
  564   1           TempAngle=(leftV-rightV);
  565   1           if(Fork_R==1)
  566   1           {
  567   1             bmq_juli+=(ECPULSE1-ECPULSE2);
  568   1           }
C251 COMPILER V5.60.0,  LQ_dianci                                                          25/09/23  21:38:01  PAGE 10  

  569   1           if(bmq_juli>=12000)
  570   1           {
  571   1             if(Go==2)Go=3;
  572   1             LED_Ctrl(LED2,OFF);
  573   1             bmq_juli=0;
  574   1           }
  575   1         }
  576   1           if(diangan[4]>1400)
  577   1           {
  578   1             Fork=0;
  579   1             Fork_R=0;
  580   1             count=1;
  581   1             time1=0;
  582   1             LED_Ctrl(LED2,OFF);
  583   1           }
  584   1         else if(Fork==1&&count==1&&time2<110) //左岔路
  585   1         {
  586   1            TempAngle=20;
  587   1            time2++;
  588   1            Fork_L = 1;
  589   1            Target_Speed =0;
  590   1         }
  591   1          else if(Fork_L==1&&time2>=110)
  592   1          {
  593   1            Target_Speed =10; 
  594   1            TempAngle=(leftV-rightV);
  595   1            if(diangan[4]>1200)
  596   1            {
  597   1             Fork=0;
  598   1             Fork_L=0;
  599   1             count=0;
  600   1             time2=0;
  601   1             LED_Ctrl(LED2,OFF);
  602   1            }
  603   1          }*/
  604   1      }
  605          void sancha3(void)    
  606          {
  607   1        if(Fork==1&&count==0&&(tly_jifen>>10)>-400) //右岔路      //纯陀螺仪积分-300，差值-40//  
  608   1         {
  609   2           Target_Speed =15;
  610   2           chazhi_sancha-=30;
  611   2           TempAngle=chazhi_sancha;
  612   2           if(TempAngle<-70)TempAngle=-70;
  613   2           Fork_R = 1;
  614   2         }
  615   1        else if(Fork_R = 1&&(tly_jifen>>10)<-400)
  616   1         {
  617   2           Forking=1;
  618   2           TempAngle=(leftV-rightV);
  619   2           if(Fork_R==1&&Forking==1)
  620   2           {
  621   3             TempAngle=(leftV-rightV);
  622   3             bmq_juli+=(ECPULSE1-ECPULSE2);      
  623   3           }
  624   2           if(bmq_juli>=11500)
  625   2           {
  626   3             if(Go==2)Go=3;
  627   3             LED_Ctrl(LED2,OFF);
  628   3             bmq_juli=0;
  629   3           }
  630   2         }
  631   1       }
  632          void Discern(void) // 环岛处理               //纯陀螺仪积分200，差值40
  633          { 
  634   1      
C251 COMPILER V5.60.0,  LQ_dianci                                                          25/09/23  21:38:01  PAGE 11  

  635   1      }
  636          void Discern3(void) // 环岛处理               //纯陀螺仪积分200，差值40
  637          { 
  638   1      
  639   1      }
  640          void Discern4(void) 
  641          {
  642   1          if(Round==1&&(tly_jifen>>10)>-200)         
  643   1          {
  644   2           chazhi_huandao-=30;
  645   2           TempAngle=chazhi_huandao;
  646   2           if(TempAngle<-70)TempAngle=-70;
  647   2          }
  648   1          if((tly_jifen>>10)<-200)
  649   1          {
  650   2            Rounding=1;
  651   2            TempAngle=(leftV-rightV);
  652   2          }
  653   1          if(Rounding==1&&(tly_jifen>>10)<-2230)      //1260
  654   1          {
  655   2            TempAngle=0;
  656   2            Round_Out = 1;
  657   2          }
  658   1          if(Round_Out==1&&bmq_juli>37500)           //39500 
  659   1          {  
  660   2                  TempAngle=(leftV-rightV);
  661   2                  Detection=0;
  662   2                  Round = 0;
  663   2                  Rounding=0;      
  664   2                  Round_Out = 0;
  665   2                  bmq_juli=0;
  666   2                  tly_jifen=0;            
  667   2                  LED_Ctrl(LED2,OFF);         
  668   2          }
  669   1      }
  670                       
  671          
  672          /*LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
  673          【函数名】void OLED_show (void)
  674          【功  能】OLED显示函数
  675          【作  者】chiusir
  676          【最后更新】2021年12月22日 
  677          【软件版本】V1.0
  678          QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ*/
  679          void OLED_show(void)
  680          {
  681   1          char txt[30];
  682   1          sprintf(txt,"LV:%04d RV:%04d",leftV,rightV);                  // 显示两个外边ADC的值
  683   1          OLED_P6x8Str(0,0,(u8*)txt);
  684   1          sprintf(txt,"LP:%04d RP:%04d",diangan[1],diangan[2]);         // 显示两个中间ADC的值
  685   1          OLED_P6x8Str(0,1,(u8*)txt);
  686   1          sprintf(txt,"ZJ:%04d T:%04d",diangan[4],TempAngle);            // 显示中间电感值和差值
  687   1          OLED_P6x8Str(0,2,(u8*)txt);
  688   1          sprintf(txt,"E:%04d %04d",ECPULSE1,ECPULSE2);                 // 显示编码器
  689   1          OLED_P6x8Str(0,3,(u8*)txt);
  690   1          sprintf(txt,"M:%04d Mt:%04d",MotorDuty1,MotorDuty2);          // 显示占空比
  691   1          OLED_P6x8Str(0,4,(u8*)txt); 
  692   1          sprintf(txt,"LY:%04d JF:%04d",Forkchu,Go);                  // 
  693   1          OLED_P6x8Str(0,5,(u8*)txt); 
  694   1      //    sprintf(txt,"LY:%05d JF:%05d",(int)(speed_i*100),tly_jifen>>10);                  // 显示蓝牙RX和积分
  695   1      //    OLED_P6x8Str(0,5,(u8*)txt);   
  696   1          sprintf(txt,"P32:%02d P33:%02d",P32,P33); 
  697   1          OLED_P6x8Str(0,6,(u8*)txt);
  698   1      //    sprintf(txt,"P:%04d D:%04d",(int)(dir_p*10),(int)(dir_d*10)); // 显示pid的值
  699   1      //    OLED_P6x8Str(0,6,(u8*)txt);
  700   1        
C251 COMPILER V5.60.0,  LQ_dianci                                                          25/09/23  21:38:01  PAGE 12  

  701   1          /*sprintf(txt,"LV:%06d RV:%06d",aacx1,aacy1);            
  702   1          OLED_P6x8Str(0,0,(u8*)txt);
  703   1          sprintf(txt,"LP:%06d RP:%06d",aacz1,gyrox1);         
  704   1          OLED_P6x8Str(0,1,(u8*)txt);
  705   1          sprintf(txt,"ZJ:%06d %06d",gyroy1,gyroz1);                    
  706   1          OLED_P6x8Str(0,2,(u8*)txt);
  707   1          sprintf(txt,"R:%01d %01d",Round,Rounding);                  
  708   1          OLED_P6x8Str(0,6,(u8*)txt);*/
  709   1          
  710   1          //(0xF1,leftV,diangan[0],rightV,diangan[3],diangan[4],diangan[1],diangan[2],Out_s);
  711   1      }
  712          
  713          
  714          
  715          
  716          
  717          
  718          
  719          
  720          
  721          
  722          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      4771     ------
  ecode size           =    ------     ------
  data size            =        10     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        72         30
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       345     ------
End of Module Information.


C251 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
