#include "func.h"

u16 battery = 0;
u16 temperature  = 0;
u16 dis = 0;
int OutData[4] = {0}; 
uint8_t  Speed_Set=1;//速度档位选择
extern float Turn_R;

/***********************************/
/****************PID****************/
int  L_encoder = 0;               //小车速度
int  R_encoder = 0;
float  car_encoder_speed;           //小车编码器速度
float  car_speed = 0;            //小车的实际速度
int  Speed_Control_Count;
int  Turn_Control_Count;
int  Angle_Speed_Control_Count;
int  Turn_Angle_Speed_Control_Count;
float Speed_Out;
int  target_encoder_speed = 0;
int stopflag = 1;//1表示停车，0表示前进
int Speed_New_Out;
int Speed_Old_Out;
float mpu_gyro_z_offset;
/***********************************/
u8 start_car  = 0;
u8 data_adjust_flag = 0;
int duty_motor;
uint8_t showflag = 0;
uint8_t sendflag = 0;
uint8_t s_flag = 0;
uint8_t send_fuzzy_flag = 0;
float In_Out_Roundabout_I = 0;
uint8_t normal_track_line_in_ring = 0;
uint8_t OLED_Refresh = 0;
/***********************参数数组的定义************************/
int  speed_duty[10]  =  {0,170,230,350,200,0,0,0,0,0};//只用面前几个速度  350  400
//int speed_encoder[10] = {214,275,334,389,445,504,564,644,698,755 };//不同占空比对应的编码器数值
//float cs_p[10] = {0,0,0,0,0,0,0,0,0,0};//差速的p
float cs_d[10] = {0,0,0,0,0,0,0,0,0,0};//差速的d
int encoder[8] = {400,0,0,0,0,0,0,0};//不同速度下入环岛的编码器数值
int speed_min[10] = { 0,0,0,0,0,0,0,0,0,0 };//差速的最小值
int speed_max[10] = { 0,0,0,0,0,0,0,0,0,0 };//差速的最大值
uint8_t Lose_Line_Flag = 0;
int encoder_cnt = 0;
float cross_p = 50;
float cross_i = 0.6;
float cross_d = 0;
/**********起跑线相关变量********/
//uint8_t start_car = 0;
/**********起跑线相关变量********/
/**********按键扫描相关变量********/
unsigned char KeySta[4][4] = {  
    {1, 1, 1, 1},  {1, 1, 1, 1},  {1, 1, 1, 1},  {1, 1, 1, 1}
};

unsigned char backup[4][4] = {  
    {1, 1, 1, 1},  {1, 1, 1, 1},  {1, 1, 1, 1},  {1, 1, 1, 1}
};

uint8_t press_key = 0;
uint8_t last_send = 0;
short plus_minus = 1;
uint8_t last_show = 1;
int dir_pwm = 0;
/**********按键扫描相关变量********/
/**********flash相关变量********/

uint32 write_buf[60];
uint32 read_buf[60];

float write_float[60];
float read_float[60];

/**********flash相关变量********/
/**********赛道信息采集相关变量********/
int max_normal_elect = 0;

/**********赛道信息采集相关变量********/

void WriteFlash()
{
    FLASH_EraseSector(1);
    write_buf[0] = AD_max[0];
    write_buf[1] = AD_max[1];
    write_buf[2] = AD_max[2];
    write_buf[3] = AD_max[3];
    write_buf[4] = AD_max[4];
    write_buf[5] = last_send;
    write_buf[6] = REFIND_LINE;
    write_buf[7]  = sendflag;
    write_buf[8]  = Lose_Line_Thres;
    write_buf[9]  = Circle_elect_thres;
    write_buf[10] = circle_up_thres;
    write_buf[11] = lose_in_circle;
    write_buf[12] = losingadd ;
//    write_buf[13] = out_garbage;
    write_buf[14] = Speed_Set ;
    write_buf[15] = kd_elc;
    write_buf[16]  = gryo_circle;
    write_buf[17] = speed_duty[1];
    write_buf[18] = speed_duty[2];
    write_buf[19] = speed_duty[3] ;
    write_buf[20]  = speed_duty[4];
    write_buf[21]  = speed_duty[5];
    write_buf[22]  = speed_duty[6];
//    write_buf[23] = speed_duty[6];
//    write_buf[11] = risingadd;
//    write_buf[12] = losingadd;
//    write_buf[13] = k_ring;
//    write_buf[14] = Speed_Set;
//    write_buf[15] = kd_elc;
    
    FLASH_WriteBuf(1, (uint8_t *)write_buf, sizeof(write_buf), 0);
    
    FLASH_EraseSector(2);
    write_float[0] = cs_p;
    write_float[1] = gyroy_d;
    write_float[2] = cross_p;
    write_float[3] = cross_i;
    write_float[4] = cross_d;
    write_float[5] = elec_k;
    write_float[6] = elec_k_r;
    write_float[7] = up_elec_l;
    write_float[8] = up_elec_r;
    
    
    FLASH_WriteBuf(2, (uint8_t *)write_float, sizeof(write_float), 0);
    
}

void Read_Flash()
{
    FLASH_ReadBuff(1, 0, sizeof(write_buf), (char *)read_buf);
    AD_max[0] = read_buf[0];
    AD_max[1] = read_buf[1];
    AD_max[2] = read_buf[2];
    AD_max[3] = read_buf[3];
    AD_max[4] = read_buf[4];
    last_send = read_buf[5];
    REFIND_LINE = read_buf[6];
    sendflag = read_buf[7];
    Lose_Line_Thres = read_buf[8];
    Circle_elect_thres = read_buf[9];
    circle_up_thres = read_buf[10];
    lose_in_circle = read_buf[11];
    losingadd  = read_buf[12];
//    out_garbage = read_buf[13];
    Speed_Set =  read_buf[14];
    kd_elc = read_buf[15];
    gryo_circle = read_buf[16];
    speed_duty[1] = read_buf[17];
    speed_duty[2] = read_buf[18];
    speed_duty[3] = read_buf[19];
    speed_duty[4] = read_buf[20];
    speed_duty[5] = read_buf[21];
    speed_duty[6]  = read_buf[22];
//    k_ring = read_buf[13];
//    Speed_Set =  read_buf[14];
//    kd_elc = read_buf[15] ;
    
    FLASH_ReadBuff(2, 0, sizeof(write_float), (char *)read_float);
    cs_p = read_float[0];
    gyroy_d = read_float[1];
    cross_p = read_float[2];
    cross_i = read_float[3];
    cross_d = read_float[4];
    elec_k = read_float[5];
    elec_k_r = read_float[6];
    up_elec_l = read_float[7];
    up_elec_r = read_float[8];
   
}

void ShowMenu(void)
{ 
    char txt[20];
    
    if(s_flag == 1){
          OLED_CLS();  
          s_flag = 0;
    
          
        switch(last_show){
            case 1://电感相关信息
              {
                sprintf(txt, "maxL:%d", AD_max[0]);
                OLED_P6x8Str(0, 0, (uint8_t*)txt);
                
                sprintf(txt,"maxM:%d", AD_max[1]);
                OLED_P6x8Str(0, 1, (uint8_t*)txt);
                
                sprintf(txt,"maxR:%d",AD_max[2]);
                OLED_P6x8Str(0,2,(uint8_t*)txt);
                
                sprintf(txt,"maxUL:%d",AD_max[3]);
                OLED_P6x8Str(0,3,(uint8_t*)txt);      
           
                sprintf(txt,"maxUR:%d",AD_max[4]);
                OLED_P6x8Str(0,4,(uint8_t*)txt);
        
                sprintf(txt, "L:%.2f", elect_L);
                OLED_P6x8Str(65, 0, (uint8_t*)txt);
        
                sprintf(txt, "M:%.2f", elect_M);
                OLED_P6x8Str(65, 1, (uint8_t*)txt);
        
                sprintf(txt, "R:%.2f", elect_R);
                OLED_P6x8Str(65, 2, (uint8_t*)txt);
                
                sprintf(txt, "UL:%.2f", elect_Up_L);
                OLED_P6x8Str(65, 3, (uint8_t*)txt);
                
                sprintf(txt, "UR:%.2f", elect_Up_R);
                OLED_P6x8Str(65, 4, (uint8_t*)txt);
                
                sprintf(txt, "elect_val:%.3f", curr_elect_val);
                OLED_P6x8Str(0, 5, (uint8_t*)txt);
                
                sprintf(txt, "up_elect_val:%.3f", up_curr_elect_val);
                OLED_P6x8Str(0, 6, (uint8_t*)txt);
                
                sprintf(txt, "out_garbage:%d", out_garbage);
                OLED_P6x8Str(0, 7, (uint8_t*)txt);
                
              }
              break;
            case 2:       
              {
                  sprintf(txt, "loseThres:%d", Lose_Line_Thres);
                  OLED_P6x8Str(0, 0, (uint8_t*)txt);
                  
                  sprintf(txt, "refindLine:%d", REFIND_LINE);
                  OLED_P6x8Str(0, 1, (uint8_t*)txt);
                  
                  sprintf(txt, "elec_k:%.3f", elec_k);
                  OLED_P6x8Str(0, 2, (uint8_t*)txt);
                  
                  sprintf(txt, "elec_k_r:%.3f", elec_k_r);
                  OLED_P6x8Str(0, 3, (uint8_t*)txt);  
                    
                  sprintf(txt, "lose_in_circle:%d", lose_in_circle);
                  OLED_P6x8Str(0, 4, (uint8_t*)txt);
                    
                  sprintf(txt, "gryo_circle:%d", gryo_circle);
                  OLED_P6x8Str(0, 5, (uint8_t*)txt);
                    
                  sprintf(txt, "Roundabout_I:%.3f", In_Out_Roundabout_I);
                  OLED_P6x8Str(0, 6, (uint8_t*)txt);
     
//                    for(uint8_t i=0; i<128; i++)
//                    {
//                      OLED_Set_Pos(i , 7); 
//                      if(ccd_buf[i] > 300)	      			
//                        OLED_WrDat(0xFF);
//                      else
//                        OLED_WrDat(0x00);	
//                    }
              }
              break;
            case 3:
              {
                sprintf(txt, "sendflag:%d", sendflag);
                OLED_P6x8Str(0, 0, (uint8_t*)txt);
                
                sprintf(txt, "up_elec_l:%.3f", up_elec_l);
                OLED_P6x8Str(0, 1, (uint8_t*)txt);
               
                sprintf(txt, "up_elec_r:%.3f", up_elec_r);
                OLED_P6x8Str(0, 2, (uint8_t*)txt);
                
                sprintf(txt, "Speed_Set:%d", Speed_Set);
                OLED_P6x8Str(0, 6, (uint8_t*)txt);
                                
                sprintf(txt, "duty_motor:%d", duty_motor);
                OLED_P6x8Str(0, 7, (uint8_t*)txt);
              }
              break;
            case 4:
              {
                   sprintf(txt, "losingadd:%d", losingadd);
                   OLED_P6x8Str(0, 0, (uint8_t*)txt);
               
                   sprintf(txt, "CircleThres:%d", Circle_elect_thres);
                   OLED_P6x8Str(0, 2, (uint8_t*)txt);
                     
                   sprintf(txt, "circle_up_thres:%d", circle_up_thres);
                   OLED_P6x8Str(0, 3, (uint8_t*)txt); 
                     
               
                   sprintf(txt, "accsenser:%d", accsenser);
                   OLED_P6x8Str(0, 6, (uint8_t*)txt);
                     
                   sprintf(txt, "gyrosensor:%d", gyrosensor);
                   OLED_P6x8Str(0, 7, (uint8_t*)txt);
              }
              break;
            case 5:
              {
               sprintf(txt, "cs_p:%.3f", cs_p);
               OLED_P6x8Str(0, 0, (uint8_t*)txt);
            
               sprintf(txt, "gyroy_d:%.3f", gyroy_d);
               OLED_P6x8Str(0, 1, (uint8_t*)txt);
               
               sprintf(txt, "kd_elc:%d", kd_elc);
               OLED_P6x8Str(0, 2, (uint8_t*)txt);
               
               sprintf(txt, "cross_p:%.3f", cross_p);
               OLED_P6x8Str(0, 3, (uint8_t*)txt);
               
               sprintf(txt, "cross_i:%.3f", cross_i);
               OLED_P6x8Str(0, 4, (uint8_t*)txt);
               
               sprintf(txt, "L_encoder:%d", L_encoder);
               OLED_P6x8Str(0, 6, (uint8_t*)txt);
               
               sprintf(txt, "R_encoder:%d", R_encoder);
               OLED_P6x8Str(0, 7, (uint8_t*)txt);
        }
               
              break;
            case 6:
              {
                   sprintf(txt, "straignt_speed:%d", speed_duty[1]);
                   OLED_P6x8Str(0, 0, (uint8_t*)txt);
               
                   sprintf(txt, "normal_speed:%d", speed_duty[2]);
                   OLED_P6x8Str(0, 1, (uint8_t*)txt);
                     
                   sprintf(txt, "curve_speed:%d", speed_duty[3]);
                   OLED_P6x8Str(0, 2, (uint8_t*)txt); 
                   
                   sprintf(txt, "circle_speed:%d", speed_duty[4]);
                   OLED_P6x8Str(0, 3, (uint8_t*)txt);
               
                   sprintf(txt, "undefined:%d", speed_duty[5]);
                   OLED_P6x8Str(0, 4, (uint8_t*)txt);
                     
                   sprintf(txt, "undefined:%d", speed_duty[6]);
                   OLED_P6x8Str(0, 5, (uint8_t*)txt);
                   

              }
              break;
            case 7:
              {
                   sprintf(txt, "direction_pwm:%d", direction_pwm);
                   OLED_P6x8Str(0, 1, (uint8_t*)txt);
              }
              break;
            }
    }
    
    switch(sendflag){
        case 0:
            OutData[0]=elect_L;
            OutData[1]=elect_M;
            OutData[2]=elect_R;
            OutData[3]=car_encoder_speed;
            break;
        case 1:
            OutData[0]=0;
            OutData[1]=gyroz;
            OutData[2]=curr_elect_val*500 ;
            OutData[3]=up_elect_val_delta * 2000;
            break;
        case 2:
            OutData[0]=elect_Up_L;
            OutData[1]=In_Out_Roundabout_I ;
            OutData[2]=encoder_cnt;
            OutData[3]=elect_Up_R;
            break;
        
        case 3:
            OutData[0]=L_encoder;
            OutData[1]=R_encoder;
            OutData[2]=elect_val_delta * 1000;
            OutData[3]=gyrosensor;
            break;
    }
    
           
    if(!last_send){
        OutPut_Data();
    }else{
        SendImageData();
    }
   
}

/*
 * 检测按键是否按下
 */
void Check_BottonPress()
{
  
    static uint8_t key_up=1;     //按键松开标志
    char txt[20];
    for (uint8_t i=0; i<4; i++) 
    {
        for (uint8_t j=0; j<4; j++)
        {
            if (backup[i][j] != KeySta[i][j]) 
            {
                if (backup[i][j] != 0)       
                {
                    press_key = i*4+j + 1;     
                }
                backup[i][j] = KeySta[i][j];  
            }
        }
    }
        
        
        
    switch(press_key){
        case 1:
          if(last_show == 1){
                if(!last_send){//默认发送相关数据
                    last_send = 1;
                }else{
                      last_send = 0;
                }
          }
          last_show = 1;
          break;
        case 2:       
          last_show = 2;
          break;
        case 3:          
          last_show = 3;
          break;
        case 4:
          last_show = 4;
          break;
        case 5:
          last_show = 5;
          break;
        case 6:
          last_show = 6;
          break;
        case 7:
          last_show = 7;//总共七个页面.每一页6个参数
          break;
        case 8:
          WriteFlash();
          break;               
        case 9:  //1     
          if(last_show == 2){Lose_Line_Thres += plus_minus * 10;}
          else if(last_show == 3){sendflag += plus_minus * 1;}
          else if(last_show == 4){losingadd += plus_minus * 5;}
          else if(last_show == 5){cs_p += plus_minus * 0.01;}
          else if(last_show == 6){speed_duty[1] += plus_minus * 10;}
          else if(last_show == 7){direction_pwm += plus_minus * 10;}
          break;
        case 10://2
          if(last_show == 2){REFIND_LINE += plus_minus * 5;}
          else if(last_show == 3){up_elec_l += plus_minus * 0.01;}
          else if(last_show == 4){}
          else if(last_show == 5){gyroy_d += plus_minus * 0.01;}
          else if(last_show == 6){speed_duty[2] += plus_minus * 10;}
          else if(last_show == 7){direction_pwm += plus_minus * 100;}
          break;
        case 11://3
          if(last_show == 2){elec_k += plus_minus * 0.01;}
          else if(last_show == 3){up_elec_r += plus_minus * 0.01;}
          else if(last_show == 4){Circle_elect_thres += plus_minus * 5;}
          else if(last_show == 5){kd_elc += plus_minus * 10;}
          else if(last_show == 6){speed_duty[3] += plus_minus * 10;}
          else if(last_show == 7){}
          break;
        case 12://4
          if(last_show == 2){elec_k_r += plus_minus * 0.01;}
          else if(last_show == 3){}
          else if(last_show == 4){circle_up_thres += plus_minus * 5;}
          else if(last_show == 5){cross_p += plus_minus * 1;}
          else if(last_show == 6){speed_duty[4] += plus_minus * 10;}
          else if(last_show == 7){}
          break;
        case 13://5
          if(last_show == 2){lose_in_circle += plus_minus * 5;}
          else if(last_show == 3){}
          else if(last_show == 4){}
          else if(last_show == 5){cross_i += plus_minus * 0.1;}
          else if(last_show == 6){speed_duty[5] += plus_minus * 10;}
          else if(last_show == 7){}
          break;
        case 14://6
          if(last_show == 2){gryo_circle += plus_minus * 10;}
          else if(last_show == 3){}
          else if(last_show == 4){}
          else if(last_show == 5){}
          else if(last_show == 6){speed_duty[6] += plus_minus * 10;}
          else if(last_show == 7){}
          break;
        case 15:
          Read_Flash();      
          break;
        case 16:
          if(stopflag == 0) stopflag = 1;
          else stopflag = 0;
          
          break;
    }
    press_key = 0;   
    
    if(key_up && (GPIO_PinRead(K1)==0 || GPIO_PinRead(K2)==0 || GPIO_PinRead(K3)==0 ))
    {
      delayms(100);   //消抖
      key_up=0;
      
      if(GPIO_PinRead(K1)==0)      
      {
//            sendufuzzymain();
      }
      
      if(GPIO_PinRead(K2)==0) 
      {
          if(plus_minus == 1){//默认加
                plus_minus = -1;
          }else if(plus_minus == -1){
                plus_minus = 1;
          }
      }
      
      if(GPIO_PinRead(K3)==0) 
      {
            out_ring_flag = 0;
            In_Out_Roundabout_I = 0;
            left_down_flag = 0;
            right_down_flag = 0;
            Circle_Flag = 0;
            Circle_Pre_flag = 0;
            rightDecline_amplitude = 0;
            leftDecline_amplitude = 0;
            rightRising_amplitude = 0;
            leftRising_amplitude = 0;
            rightSensorMax = 0;
            leftSensorMax = 0;
            LeftCircle_Flag = 0;
            RightCircle_Flag = 0;
            upl_elect[2] = 0;
            upl_elect[1] = 0;
            upl_elect[0] = 0;
            upr_elect[2] = 0;
            upr_elect[1] = 0;
            upr_elect[0] = 0;
            Circle_elect_thres = 970;
            losingadd = 25;
            lose_in_circle = 120;
            circle_up_thres = 800;
            Lose_Line_Thres = 70;
            REFIND_LINE   = 75;
            gryo_circle = 200;
            //发车相关变量
            start_car = 0;
            out_garbage = 0;
            //舵机相关变量
            kd_elc = 150;
            gyroy_d = 2; 
            elec_k = 0.8;
            elec_k_r = 1.2;
            up_elec_l  = 1;
            up_elec_r = 1;
            //丢线相关变量
            lose_line = 0;
            //开车变量
            stopflag = 1;
            //入库相关变量
            into_garage_enable = 0;
      }
      
    }
    
    if(GPIO_PinRead(K1)==1 && GPIO_PinRead(K2)==1 && GPIO_PinRead(K3)==1 ) 
    {
        key_up=1;   
    }
   
}

//模拟压栈，方向:new -> old,压float
void Push_And_Pull(float *buff,int len,float newdata)
{
    int i;
    for(i=len-1;i>0;i--)
    {
        *(buff+i)=*(buff+i-1);
    }
    *buff=newdata; 
}
//模拟压栈，方向:new -> old,压int
void Int_Push_And_Pull(int *buff,int len,int newdata)
{
    int i;
    for(i=len-1;i>0;i--)
    {
        *(buff+i)=*(buff+i-1);
    }
    *buff=newdata; 
}

float Slope_Calculate(uint8 begin,uint8 end,float *p)    //最小二乘法拟合斜率
{
   float xsum=0,ysum=0,xysum=0,x2sum=0;
   uint8 i=0;
   float result=0;
   static float resultlast;
   p=p+begin;
   for(i=begin;i<end;i++)
   {
	   xsum+=i;
	   ysum+=*p;
	   xysum+=i*(*p);
	   x2sum+=i*i;
	   p=p+1;
   }
  if((end-begin)*x2sum-xsum*xsum) //判断除数是否为零 
  {
    result=((end-begin)*xysum-xsum*ysum)/((end-begin)*x2sum-xsum*xsum);
    resultlast=result;
  }
  else
  {
   result=resultlast;
  }
  return result;
}

void LED()
{
  if( right_down_flag == 1)
  { 
        LED_ON(LED_2);
  }
  else
  {
        LED_OFF(LED_2);
  }

  if( Circle_Pre_flag == 1)
  { 
        LED_ON(LED_5);
  }
  else
  {
        LED_OFF(LED_5);
  }
  
  if( Circle_Flag == 1)
  { 
        LED_ON(LED_6);
  }
  else
  {
        LED_OFF(LED_6);
  }
  
  if(!last_send){
        _LED_ON(LED_9);
  }else{
        _LED_OFF(LED_9);
  } 
  
  if(plus_minus == 1){
        _LED_ON(LED_10);
  }else if(plus_minus == -1){
        _LED_OFF(LED_10);
  } 
  
//    if(plus_minus == 1){
//        _LED_ON(LED_11);
//  }else if(plus_minus == -1){
//        _LED_OFF(LED_11);
//  } 
//  
//    if(plus_minus == 1){
//        _LED_ON(LED_12);
//  }else if(plus_minus == -1){
//        _LED_OFF(LED_12);
//  } 
  
}

void SendImageData(void) 
{
   uint8 i = 0;
   UART_PutChar(UART4,0x00); 
   UART_PutChar(UART4,0xff);
   UART_PutChar(UART4,0x01);
   UART_PutChar(UART4,0x00);
   
   for(i=0; i<128; i++)                        //数据
   {
      UART_PutChar(UART4,ccd_buf[i]>>8);   //发送高8位
      UART_PutChar(UART4,ccd_buf[i]&0XFF); //发送高低8位
   }
}

//==========================================
//函数名CRC_CHECK() 
//作用：  循环冗余校验，供波形输出函数调用
//==========================================
unsigned short CRC_CHECK(unsigned char *Buf, unsigned char CRC_CNT)
{
    unsigned short CRC_Temp;
    unsigned char i,j;
    CRC_Temp = 0xffff;

    for (i=0;i<CRC_CNT; i++){      
        CRC_Temp ^= Buf[i];
        for (j=0;j<8;j++) {
            if (CRC_Temp & 0x01)
                CRC_Temp = (CRC_Temp >>1 ) ^ 0xa001;
            else
                CRC_Temp = CRC_Temp >> 1;
        }
    }
    return(CRC_Temp);
}

//==========================================
//函数名OutPut_Data() 
//作用：  波形输出，用虚拟示波器看波形时调用此函数发送数据
//==========================================
void OutPut_Data()
{
  int temp[4] = {0};
  unsigned int temp1[4] = {0};
  unsigned char databuf[10] = {0};
  unsigned char i;
  unsigned short CRC16 = 0;
  for(i=0;i<4;i++)
   {  
    temp[i]  = (int)OutData[i];
    temp1[i] = (unsigned int)temp[i];   
   }
   
  for(i=0;i<4;i++) 
  {
    databuf[i*2]   = (unsigned char)(temp1[i]%256);
    databuf[i*2+1] = (unsigned char)(temp1[i]/256);
  }
  
  CRC16 = CRC_CHECK(databuf,8);
  databuf[8] = CRC16%256;
  databuf[9] = CRC16/256;
  for(i=0;i<10;i++)
  {
   UART_PutChar(UART4,databuf[i]);
  }
}

void sendufuzzymain()
{
  char txt[10];
//  if(send_fuzzy_flag){
      UART_PutStr(UART4, "*");
      for(int i = 0;i<8;i++){  
        sprintf(txt,"%d",fuzzy_txt[i]);
        if(i==0 || i == 2 || i == 4 || i == 6){
            UART_PutStr (UART4, "[");
            UART_PutStr (UART4, txt);
            UART_PutStr (UART4, ".");
        }
        else{
            UART_PutStr (UART4, txt);
            UART_PutStr (UART4, "]");
        }       
      } 
//  }
}

void KeyScan()
{
    unsigned char i;
    static unsigned char keyout = 0;  
    static unsigned char keybuf[4][4] = { 
        {0xFF, 0xFF, 0xFF, 0xFF},  {0xFF, 0xFF, 0xFF, 0xFF},
        {0xFF, 0xFF, 0xFF, 0xFF},  {0xFF, 0xFF, 0xFF, 0xFF}
    };
    
    keybuf[keyout][0] = (keybuf[keyout][0] << 1) | INPUT_STATE(KEY_IN_1);
    keybuf[keyout][1] = (keybuf[keyout][1] << 1) | INPUT_STATE(KEY_IN_2);
    keybuf[keyout][2] = (keybuf[keyout][2] << 1) | INPUT_STATE(KEY_IN_3);
    keybuf[keyout][3] = (keybuf[keyout][3] << 1) | INPUT_STATE(KEY_IN_4);

    for (i=0; i<4; i++)  
    {
        if ((keybuf[keyout][i] & 0x0F) == 0x00)
        {  
            KeySta[keyout][i] = 0;
        }
        else if ((keybuf[keyout][i] & 0x0F) == 0x0F)
        {  
            KeySta[keyout][i] = 1;
        }
    }

    keyout++;               
    keyout = keyout & 0x03;  
    switch (keyout)          
    {
        case 0: GPIO_PinWrite(KEY_OUT_4 , 1); GPIO_PinWrite(KEY_OUT_1 , 0); break;
        case 1: GPIO_PinWrite(KEY_OUT_1 , 1); GPIO_PinWrite(KEY_OUT_2 , 0); break;
        case 2: GPIO_PinWrite(KEY_OUT_2 , 1); GPIO_PinWrite(KEY_OUT_3 , 0); break;
        case 3: GPIO_PinWrite(KEY_OUT_3 , 1); GPIO_PinWrite(KEY_OUT_4 , 0); break;
        default: break;
    }
}

